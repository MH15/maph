{"version":3,"sources":["fparse/fparse.js"],"names":["root","Formula","fStr","topFormula","formulaExpression","variables","formulaStr","parse","toSplit","pCount","paramStr","params","i","length","push","s","constants","replace","forEach","RegExp","c","Math","str","cleanupInputString","lastChar","act","state","expressions","char","tmp","funcName","charAt","match","isOperator","createVariableEvaluator","registerVariable","Number","Error","createFunctionEvaluator","varName","indexOf","valueObj","item","left","right","runAgain","results","Array","evaluate","workArr","getExpression","console","error","pow","splice","arg","fname","args","splitFunctionParams","me","innerValues","apply","varname","valObj","undefined","formula","exports","module","window"],"mappings":"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","file":"fparse.c33771cc.map","sourceRoot":"..","sourcesContent":["/**\n * JS Formula Parser\n * -------------------\n * (c) 2012-2014 Alexander Schenkel, alex@alexi.ch\n *\n * JS Formula Parser takes a string, parses its mathmatical formula\n * and creates an evaluatable Formula object of it.\n *\n * Example input:\n *\n * var fObj = new Formula('sin(PI*x)/(2*PI)');\n * var result = fObj.evaluate({x: 2});\n * var results = fObj.evaluate([\n *     {x: 2},\n *     {x: 4},\n *     {x: 8}\n * ]);\n *\n * LICENSE:\n * -------------\n * Copyright 2012-2018 Alexander Schenkel, alex@alexi.ch\n * You can use this library for and within whatever you want,\n * but please put a reference to me in your project and drop me a message, thanks.\n */\n\n(function(root) {\n    // root / window handler, to support browser export\n    root = root || this;\n\n    class Formula {\n        constructor(fStr, topFormula = null) {\n            this.formulaExpression = null;\n            this.variables = [];\n            this.topFormula = topFormula || null;\n\n            this.formulaStr = fStr;\n            this.formulaExpression = this.parse(fStr);\n\n            return this;\n        }\n\n        /**\n         *\n         * Splits the given string by ',', makes sure the ',' is not within\n         * a sub-expression\n         * e.g.: str = \"x,pow(3,4)\" returns 2 elements: x and pow(3,4).\n         */\n        splitFunctionParams(toSplit) {\n            // do not split on ',' within matching brackets.\n            let pCount = 0,\n                paramStr = '';\n            const params = [];\n            for (let i = 0; i < toSplit.length; i++) {\n                if (toSplit[i] === ',' && pCount === 0) {\n                    // Found function param, save 'em\n                    params.push(paramStr);\n                    paramStr = '';\n                } else if (toSplit[i] === '(') {\n                    pCount++;\n                    paramStr += toSplit[i];\n                } else if (toSplit[i] === ')') {\n                    pCount--;\n                    paramStr += toSplit[i];\n                    if (pCount < 0) {\n                        throw 'ERROR: Too many closing parentheses!';\n                    }\n                } else {\n                    paramStr += toSplit[i];\n                }\n            }\n            if (pCount !== 0) {\n                throw 'ERROR: Too many opening parentheses!';\n            }\n            if (paramStr.length > 0) {\n                params.push(paramStr);\n            }\n            return params;\n        }\n\n        /**\n         * Cleans the input string from unnecessary whitespace,\n         * and replaces some known constants:\n         */\n        cleanupInputString(s) {\n            const constants = ['PI', 'E', 'LN2', 'LN10', 'LOG2E', 'LOG10E', 'SQRT1_2', 'SQRT2'];\n\n            s = s.replace(/[\\s]+/, '');\n            constants.forEach(c => {\n                s = s.replace(new RegExp('([^A-Za-z0-9_]+|^)' + c + '([^A-Za-z]+|$)'), '$1' + Math[c] + '$2');\n            });\n            return s;\n        }\n\n        /**\n         * So... How do we parse a formula?\n         * first, we have to split the items into 'expressions': An expression can be:\n         *   - a number, e.g. '3.45'\n         *   - an unknown variable, e.g. 'x'\n         *   - a single char operator, such as '*','+' etc...\n         *   - a named variable, in [], e.g. [myvar]\n         *   - a function, such as sin(x)\n         *   - a parenthessed expression, containing other expressions\n         *\n         * So where do we begin....? at the beginning, I would say: Parse the string from\n         * left to right, using a state machine: each time a char is read, decide which\n         * state we are in or into which state we have to change.\n         */\n        parse(str) {\n            // First of all: Away with all we don't have a need for:\n            // Additionally, replace some constants:\n            str = this.cleanupInputString(str);\n\n            let lastChar = str.length - 1,\n                act = 0,\n                state = 0,\n                expressions = [],\n                char = '',\n                tmp = '',\n                funcName = null,\n                pCount = 0;\n\n            while (act <= lastChar) {\n                switch (state) {\n                    case 0:\n                        // None state, the beginning. Read a char and see what happens.\n                        char = str.charAt(act);\n                        if (char.match(/[0-9.]/)) {\n                            // found the beginning of a number, change state to \"within-number\"\n                            state = 'within-nr';\n                            tmp = '';\n                            act--;\n                        } else if (this.isOperator(char)) {\n                            // Simple operators. Note: '-' must be treaten specially,\n                            // it could be part of a number.\n                            // it MUST be part of a number if the last found expression\n                            // was an operator (or the beginning):\n                            if (char === '-') {\n                                if (\n                                    expressions.length === 0 ||\n                                    (expressions[expressions.length - 1] &&\n                                        typeof expressions[expressions.length - 1] === 'string')\n                                ) {\n                                    state = 'within-nr';\n                                    tmp = '-';\n                                    break;\n                                }\n                            }\n\n                            // Found a simple operator, store as expression:\n                            if (act === lastChar || this.isOperator(expressions[act - 1])) {\n                                state = -1; // invalid to end with an operator, or have 2 operators in conjunction\n                                break;\n                            } else {\n                                expressions.push(char);\n                                state = 0;\n                            }\n                        } else if (char === '(') {\n                            // left parenthes found, seems to be the beginning of a new sub-expression:\n                            state = 'within-parentheses';\n                            tmp = '';\n                            pCount = 0;\n                        } else if (char === '[') {\n                            // left named var separator char found, seems to be the beginning of a named var:\n                            state = 'within-named-var';\n                            tmp = '';\n                        } else if (char.match(/[a-zA-Z]/)) {\n                            // multiple chars means it may be a function, else its a var which counts as own expression:\n                            if (act < lastChar && str.charAt(act + 1).match(/[a-zA-Z]/)) {\n                                tmp = char;\n                                state = 'within-func';\n                            } else {\n                                // Single variable found:\n                                // We need to check some special considerations:\n                                // - If the last char was a number (e.g. 3x), we need to create a multiplication out of it (3*x)\n                                if (expressions.length > 0) {\n                                    if (typeof expressions[expressions.length - 1] === 'number') {\n                                        expressions.push('*');\n                                    }\n                                }\n                                expressions.push(this.createVariableEvaluator(char));\n                                this.registerVariable(char);\n                                state = 0;\n                                tmp = '';\n                            }\n                        }\n                        break;\n                    case 'within-nr':\n                        char = str.charAt(act);\n                        if (char.match(/[0-9.]/)) {\n                            //Still within number, store and continue\n                            tmp += char;\n                            if (act === lastChar) {\n                                expressions.push(Number(tmp));\n                                state = 0;\n                            }\n                        } else {\n                            // Number finished on last round, so add as expression:\n                            if (tmp === '-') {\n                                // just a single '-' means: a variable could follow (e.g. like in 3*-x), we convert it to -1: (3*-1x)\n                                tmp = -1;\n                            }\n                            expressions.push(Number(tmp));\n                            tmp = '';\n                            state = 0;\n                            act--;\n                        }\n                        break;\n\n                    case 'within-func':\n                        char = str.charAt(act);\n                        if (char.match(/[a-zA-Z]/)) {\n                            tmp += char;\n                        } else if (char === '(') {\n                            funcName = tmp;\n                            tmp = '';\n                            pCount = 0;\n                            state = 'within-func-parentheses';\n                        } else {\n                            throw new Error('Wrong character for function at position ' + act);\n                        }\n\n                        break;\n\n                    case 'within-named-var':\n                        char = str.charAt(act);\n                        if (char === ']') {\n                            // end of named var, create expression:\n                            expressions.push(this.createVariableEvaluator(tmp));\n                            this.registerVariable(tmp);\n                            tmp = '';\n                            state = 0;\n                        } else if (char.match(/[a-zA-Z0-9_]/)) {\n                            tmp += char;\n                        } else {\n                            throw new Error('Character not allowed within named variable: ' + char);\n                        }\n                        break;\n\n                    case 'within-parentheses':\n                    case 'within-func-parentheses':\n                        char = str.charAt(act);\n                        if (char === ')') {\n                            //Check if this is the matching closing parenthesis.If not, just read ahead.\n                            if (pCount <= 0) {\n                                // Yes, we found the closing parenthesis, create new sub-expression:\n                                if (state === 'within-parentheses') {\n                                    expressions.push(new Formula(tmp, this));\n                                } else if (state === 'within-func-parentheses') {\n                                    // Function found: return a function that,\n                                    // when evaluated, evaluates first the sub-expression\n                                    // then returns the function value of the sub-expression.\n                                    // Access to the function is private within the closure:\n                                    expressions.push(this.createFunctionEvaluator(tmp, funcName));\n                                    funcName = null;\n                                }\n                                state = 0;\n                            } else {\n                                pCount--;\n                                tmp += char;\n                            }\n                        } else if (char === '(') {\n                            // begin of a new sub-parenthesis, increase counter:\n                            pCount++;\n                            tmp += char;\n                        } else {\n                            // all other things are just added to the sub-expression:\n                            tmp += char;\n                        }\n                        break;\n                }\n                act++;\n            }\n\n            if (state !== 0) {\n                throw new Error('Could not parse formula: Syntax error.');\n            }\n\n            return expressions;\n        }\n\n        isOperator(char) {\n            return typeof char === 'string' && char.match(/[\\+\\-\\*\\/\\^]/);\n        }\n\n        registerVariable(varName) {\n            if (this.topFormula instanceof Formula) {\n                this.topFormula.registerVariable(varName);\n            } else {\n                if (this.variables.indexOf(varName) < 0) {\n                    this.variables.push(varName);\n                }\n            }\n        }\n\n        getVariables() {\n            if (this.topFormula instanceof Formula) {\n                return this.topFormula.variables;\n            } else {\n                return this.variables;\n            }\n        }\n\n        /**\n         * here we do 3 steps:\n         * 1) evaluate (recursively) each element of the given array so that\n         *    each expression is broken up to a simple number.\n         * 2) now that we have only numbers and simple operators left,\n         *    calculate the high value operator sides (*,/)\n         * 3) last step, calculate the low value operators (+,-), so\n         *    that in the end, the array contains one single number.\n         * Return that number, aka the result.\n         */\n        evaluate(valueObj) {\n            let i = 0,\n                item = 0,\n                left = null,\n                right = null,\n                runAgain = true;\n            const results = [];\n\n            if (valueObj instanceof Array) {\n                for (i = 0; i < valueObj.length; i++) {\n                    results[i] = this.evaluate(valueObj[i]);\n                }\n                return results;\n            }\n\n            // Step 0: do a working copy of the array:\n            const workArr = [];\n            for (i = 0; i < this.getExpression().length; i++) {\n                workArr.push(this.getExpression()[i]);\n            }\n            // Step 1, evaluate\n            for (i = 0; i < workArr.length; i++) {\n                /**\n                 * An element can be:\n                 *  - a number, so just let it alone for now\n                 *  - a string, which is a simple operator, so just let it alone for now\n                 *  - a function, which must return a number: execute it with valueObj\n                 *    and replace the item with the result.\n                 *  - another Formula object: resolve it recursively using this function and\n                 *    replace the item with the result\n                 */\n                item = workArr[i];\n                if (typeof item === 'function') {\n                    workArr[i] = item(valueObj);\n                } else if (item instanceof Formula) {\n                    workArr[i] = item.evaluate(valueObj);\n                } else if (typeof item !== 'number' && typeof item !== 'string') {\n                    console.error('UNKNOWN OBJECT IN EXPRESSIONS ARRAY!', item);\n                    throw new Error('Unknown object in Expressions array');\n                }\n            }\n\n            // Now we should have a number-only array, let's evaulate the '^' operator:\n            while (runAgain) {\n                runAgain = false;\n                for (i = 0; i < workArr.length; i++) {\n                    item = workArr[i];\n                    if (typeof item === 'string' && item === '^') {\n                        if (i === 0 || i === workArr.length - 1) {\n                            throw 'Wrong operator position!';\n                        }\n                        left = Number(workArr[i - 1]);\n                        right = Number(workArr[i + 1]);\n                        workArr[i - 1] = Math.pow(left, right);\n                        workArr.splice(i, 2);\n                        runAgain = true;\n                        break;\n                    }\n                }\n            }\n\n            // Now we should have a number-only array, let's evaulate the '*','/' operators:\n            runAgain = true;\n            while (runAgain) {\n                runAgain = false;\n                for (i = 0; i < workArr.length; i++) {\n                    item = workArr[i];\n                    if (typeof item === 'string' && (item === '*' || item === '/')) {\n                        if (i === 0 || i === workArr.length - 1) {\n                            throw 'Wrong operator position!';\n                        }\n                        left = Number(workArr[i - 1]);\n                        right = Number(workArr[i + 1]);\n                        workArr[i - 1] = item === '*' ? left * right : left / right;\n                        workArr.splice(i, 2);\n                        runAgain = true;\n                        break;\n                    }\n                }\n            }\n\n            // Now we should have a number-only array, let's evaulate the '+','-' operators:\n            runAgain = true;\n            while (runAgain) {\n                runAgain = false;\n                for (i = 0; i < workArr.length; i++) {\n                    item = workArr[i];\n                    if (typeof item === 'string' && (item === '+' || item === '-')) {\n                        if (i === 0 || i === workArr.length - 1) {\n                            throw new Error('Wrong operator position!');\n                        }\n                        left = Number(workArr[i - 1]);\n                        right = Number(workArr[i + 1]);\n                        workArr[i - 1] = item === '+' ? left + right : left - right;\n                        workArr.splice(i, 2);\n                        runAgain = true;\n                        break;\n                    }\n                }\n            }\n\n            // In the end the original array should be reduced to a single item,\n            // containing the result:\n            return workArr[0];\n        }\n\n        getExpression() {\n            return this.formulaExpression;\n        }\n\n        /**\n         * Returns a function which acts as an expression for functions:\n         * Its inner arguments are parsed, split by comma, and evaluated\n         * first when then function is executed.\n         *\n         * Used for e.g. evaluate things like \"max(x*3,20)\"\n         *\n         * The returned function is called later by evaluate(), and takes\n         * an evaluation object with the needed values.\n         */\n        createFunctionEvaluator(arg, fname) {\n            // Functions can have multiple params, comma separated.\n            // Split them:\n            let args = this.splitFunctionParams(arg),\n                me = this;\n            for (let i = 0; i < args.length; i++) {\n                args[i] = new Formula(args[i], me);\n            }\n            // Args now is an array of function expressions:\n            return function(valueObj) {\n                const innerValues = [];\n                for (let i = 0; i < args.length; i++) {\n                    innerValues.push(args[i].evaluate(valueObj));\n                }\n                // If the valueObj itself has a function definition with\n                // the function name, call this one:\n                if (valueObj && typeof valueObj[fname] === 'function') {\n                    return valueObj[fname].apply(me, innerValues);\n                } else if (typeof me[fname] === 'function') {\n                    // perhaps the Formula object has the function? so call it:\n                    return me[fname].apply(me, innerValues);\n                } else if (typeof Math[fname] === 'function') {\n                    // Has the JS Math object a function as requested? Call it:\n                    return Math[fname].apply(me, innerValues);\n                } else {\n                    throw 'Function not found: ' + fname;\n                }\n            };\n        }\n\n        /**\n         * Returns a function which acts as an expression evaluator for variables:\n         * It creates an intermediate function that is called by the evaluate() function\n         * with a value object. The function then returns the value from the value\n         * object, if defined.\n         */\n        createVariableEvaluator(varname) {\n            return function(valObj = {}) {\n                // valObj contains a variable / value pair: If the variable matches\n                // the varname found as expression, return the value.\n                // eg: valObj = {x: 5,y:3}, varname = x, return 5\n                if (valObj[varname] !== undefined) {\n                    return valObj[varname];\n                } else {\n                    throw new Error('Cannot evaluate ' + varname + ': No value given');\n                }\n            };\n        }\n\n        static calc(formula, valueObj) {\n            valueObj = valueObj || {};\n            return new Formula(formula).evaluate(valueObj);\n        }\n    }\n\n    /** Node JS Export */\n    if (typeof exports !== 'undefined') {\n        if (typeof module !== 'undefined' && module.exports) {\n            exports = module.exports = Formula;\n        }\n        exports.Formula = Formula;\n    } else {\n        root.Formula = Formula;\n    }\n})(typeof window !== 'undefined' ? window : null);\n"]}